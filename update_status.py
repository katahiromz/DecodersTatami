#!/usr/bin/env python

import config
targets = config.targets

import sys
if len(sys.argv) >= 2:
    targets = sys.argv[1:]

import glob
import re
import os

progress_map = {}
total_func_num = 0
done_func_num = 0

def update(target):
    global progress_map, total_func_num, done_func_num
    print("update_status.py: Checking alias in " + target + "...")
    alias_dir = target + '/alias'
    if not(os.path.isdir(alias_dir)):
        os.mkdir(alias_dir)
    asm_dir = target + '/analysis'
    asm_files = glob.glob(asm_dir + '/*.asm')
    for asm_file in asm_files:
        result = re.search('[/\\\\](Func.+).asm$', asm_file)
        if not(result):
            continue
        func_name = result.group(1)
        with open(asm_file, "r") as fin:
            lines = [fin.readline()]
            lines.append(fin.readline())
            lines.append(fin.readline())
            lines.append(fin.readline())
            contents = "".join(lines)
            ich1 = contents.find('[[jumponly]]')
            ich2 = lines[0].find('proc imp.')
            result = re.search('[/\\\\](Func.+).asm$', asm_file)
            if ich1 == -1 or ich2 == -1:
                continue
            result = re.search('proc imp\.([^\s]+) ', lines[0])
            if not(result):
                continue
            alias_name = result.group(1)
            analysis_file = target + '/analysis/' + func_name + ".txt"
            with open(analysis_file, "w") as fout:
                fout.write(
                    "# This file is automatically generated by update_status.py\n" +
                    "\n" +
                    "```asm\n" +
                    lines[0].rstrip() + "\n" +
                    "```\n" +
                    "[=>]\n" +
                    "```txt\n" +
                    "Function '" + func_name + " is alias of '" + alias_name + "'.\n" +
                    "```\n\n" +
                    "Q.E.D.\n")
            alias_file = alias_dir + '/' + func_name + '.txt'
            if not(os.path.isfile(alias_file)):
                with open(alias_file, "w") as fout:
                    fout.write(alias_name)
    # write README.md and index.html
    print("update_status.py: Updating status at " + target + "...")
    alias_dir = target + '/alias'
    analysis_dir = target + '/analysis'
    analysis_files = glob.glob(analysis_dir + '/Func*.txt')
    total_func_num += len(analysis_files)
    target_funcs = []
    target_done = []
    alias_dict = {}
    analysis_dict = {}
    for analysis_file in analysis_files:
        alias_name = ''
        result = re.search('[/\\\\](Func.+).txt$', analysis_file)
        if not(result):
            continue
        func_name = result.group(1)
        target_funcs.append(func_name)
        done = False
        with open(analysis_file, "r") as fin:
            lines = fin.readlines()
            contents = "".join(lines)
            if contents != '':
                analysis_dict[func_name] = contents
            if contents.find("Q.E.D") != -1:
                done = True
        if done:
            target_done.append(func_name)
            done_func_num += 1
        alias_file = alias_dir + '/' + func_name + '.txt'
        if os.path.isfile(alias_file):
            line = ''
            with open(alias_file, "r") as fin:
                line = fin.readline()
            if line != '':
                alias_dict[func_name] = line.rstrip()
    readme_file = target + '/README.md'
    print("update_status.py: Updating " + readme_file)
    contents = ''
    try:
        with open(readme_file, "r") as fin:
            lines = fin.readlines()
            contents = "".join(lines)
    except:
        pass
    ich1 = contents.find('## Status')
    if ich1 == -1:
        ich1 = contents.find('# Status')
    ich2 = -1
    if ich1 != -1:
        ich2 = contents.find('##', ich1 + 9)
        if ich2 == -1:
            ich2 = len(contents)
    else:
        ich1 = ich2 = len(contents)
    head = tail = ''
    if ich1 != -1:
        head = contents[:ich1]
    if ich2 != -1:
        tail = contents[ich2:]
    status = "## Status\n\n"
    status += target + " has " + str(len(target_funcs)) + " functions.\n\n"
    count1 = len(target_done)
    count2 = len(target_funcs)
    if count2 > 0:
        status += "%d of %d (%.2f%%) Done.\n\n" % (count1, count2, count1 * 100.0 / count2)
    for func_name in target_funcs:
        if func_name in analysis_dict:
            status += "- [`" + func_name + "`](analysis/" + func_name + ".txt)"
            status += " ([asm](analysis/" + func_name + ".asm))"
            if func_name in alias_dict:
                status += " [==] `" + alias_dict[func_name] + "`."
            if func_name in target_done:
                status += " (Done)"
        else:
            status += "- `" + func_name;
            status += "` ([asm](analysis/" + func_name + ".asm))"
            if func_name in alias_dict:
                alias_name = alias_dict[func_name]
                if not(re.match('Func[0-9A-Fa-f]{8}', alias_name)):
                    status += " [==] `" + alias_name + "`."
        status += "\n"
    with open(readme_file, "w") as fout:
        contents = head + status + tail
        fout.write(contents)
        progress_map[target] = [count1, count2]
    html_file = target + '/status.html'
    print("update_status.py: Updating " + html_file)
    status = "<html><head><title>" + target + "</title></head><body>\n"
    status += "<header><h1>Status of " + target + "</h1></header>\n"
    status += "<p>" + target + " has " + str(len(target_funcs)) + " functions.</p>\n\n"
    count1 = len(target_done)
    count2 = len(target_funcs)
    if count2 > 0:
        status += "<p>%d of %d (%.2f%%) Done.</p>\n\n" % (count1, count2, count1 * 100.0 / count2)
    status += "<ul>\n";
    for func_name in target_funcs:
        status += "<li>";
        if func_name in analysis_dict:
            status += f"<a href=\"analysis/{func_name}.txt\">{func_name}</a>"
            status += f" (<a href=\"analysis/{func_name}.asm\">asm</a>)"
            if func_name in alias_dict:
                status += " [==] <tt>" + alias_dict[func_name] + "</tt>."
            if func_name in target_done:
                status += " (Done)"
        else:
            status += f"{func_name}"
            status += f" (<a href=\"analysis/{func_name}.asm\">asm</a>)"
            if func_name in alias_dict:
                alias_name = alias_dict[func_name]
                if not(re.match('Func[0-9A-Fa-f]{8}', alias_name)):
                    status += " [==] <tt>" + alias_name + "</tt>."
        status += "</li>\n"
    status += "</ul>\n"
    status += "<footer><hr />\n"
    import datetime
    status += f"<p>Generated by <tt>update_status.py</tt>. {datetime.datetime.now().strftime('%Y-%m-%d')}</p>\n"
    status += "</footer></body></html>\n"
    with open(html_file, "w") as fout:
        fout.write(status);

def write_top_readme():
    global progress_map, total_func_num, done_func_num
    print("update_status.py: Updating top README.md...")
    readme_file = 'README.md'
    contents = ''
    try:
        with open(readme_file, "r") as fin:
            lines = fin.readlines()
            contents = "".join(lines)
    except:
        pass
    ich1 = contents.find('## Status')
    ich2 = -1
    if ich1 != -1:
        ich2 = contents.find('##', ich1 + 9)
        if ich2 == -1:
            ich2 = len(contents)
    else:
        ich1 = ich2 = len(contents)
    print("Writing top README.md...")
    status = "## Status\n\n"
    for target in progress_map:
        status += "- [" + target + "](" + target + "/README.md)"
        count1 = progress_map[target][0]
        count2 = progress_map[target][1]
        percent = 0
        if count2 > 0:
            percent = count1 * 100 / count2
        status += (" (%.2f%%)\n" % percent)
    status += "\nThere are " + str(total_func_num) + " functions "
    status += ("(%.2f%% Done).\n\n" % (done_func_num * 100.0 / total_func_num))
    head = tail = ''
    if ich1 != -1:
        head = contents[:ich1]
    if ich2 != -1:
        tail = contents[ich2:]
    contents = head + status + tail
    with open(readme_file, "w") as fout:
        fout.write(contents)

def main():
    global targets
    for target in targets:
        update(target)
    write_top_readme()

main()
